'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _uniqueId2 = require('lodash/uniqueId');

var _uniqueId3 = _interopRequireDefault(_uniqueId2);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _slate = require('slate');

var _slateReact = require('slate-react');

var _fullscreen = require('part:@sanity/components/dialogs/fullscreen?');

var _fullscreen2 = _interopRequireDefault(_fullscreen);

var _scrollContainer = require('part:@sanity/components/utilities/scroll-container');

var _scrollContainer2 = _interopRequireDefault(_scrollContainer);

var _activateOnFocus = require('part:@sanity/components/utilities/activate-on-focus');

var _activateOnFocus2 = _interopRequireDefault(_activateOnFocus);

var _default = require('part:@sanity/components/formfields/default');

var _default2 = _interopRequireDefault(_default);

var _Toolbar = require('./toolbar/Toolbar');

var _Toolbar2 = _interopRequireDefault(_Toolbar);

var _createBlockEditorOperations = require('./createBlockEditorOperations');

var _createBlockEditorOperations2 = _interopRequireDefault(_createBlockEditorOperations);

var _prepareSlateForBlockEditor = require('./util/prepareSlateForBlockEditor');

var _prepareSlateForBlockEditor2 = _interopRequireDefault(_prepareSlateForBlockEditor);

var _initializeSlatePlugins = require('./util/initializeSlatePlugins');

var _initializeSlatePlugins2 = _interopRequireDefault(_initializeSlatePlugins);

var _BlockEditor = require('./styles/BlockEditor.css');

var _BlockEditor2 = _interopRequireDefault(_BlockEditor);

var _constants = require('./constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const NOOP = () => {};

class BlockEditor extends _react2.default.Component {

  constructor(props, context) {
    super(props, context);

    this.state = {
      fullscreen: false,
      toolbarStyle: {},
      preventScroll: false,
      editorHasFocus: false
    };
    this._inputId = (0, _uniqueId3.default)('SlateBlockEditor');

    this.checkScrollHeight = () => {
      if (!this._inputContainer || !this._editorWrapper) {
        return;
      }

      const inputHeight = this._inputContainer.offsetHeight;
      const contentHeight = this._editorWrapper.offsetHeight;

      if (contentHeight > inputHeight) {
        this.setState({
          preventScroll: true
        });
      }
    };

    this.handleNodePatch = event => this.props.onNodePatch(event);

    this.handleInsertBlock = item => {
      if (item.options && item.options.inline) {
        this.operations.insertInline(item);
        return;
      }
      this.operations.insertBlock(item);
    };

    this.handleOnClickMarkButton = mark => {
      this.operations.toggleMark(mark);
    };

    this.handleOnClickListFormattingButton = (listItem, isActive) => {
      this.editor.focus();
      this.operations.toggleListItem(listItem, isActive);
    };

    this.handleAnnotationButtonClick = annotation => {
      this.editor.focus();
      if (annotation.active) {
        const value = this.props.value;

        const spans = value.inlines.filter(inline => inline.type == _constants.SLATE_SPAN_TYPE);
        spans.forEach(span => {
          this.operations.removeAnnotationFromSpan(span, annotation.type);
        });
        return;
      }
      this.operations.createFormBuilderSpan(annotation.type);
    };

    this.handleBlockStyleChange = selectedValue => {
      this.operations.setBlockStyle(selectedValue.style.value);
      this.refreshCSS();
    };

    this.handleToggleFullscreen = () => {
      this.setState(prevState => ({ fullscreen: !prevState.fullscreen }));
    };

    this.refEditor = editor => {
      this.editor = editor;
    };

    this.refBlockDragMarker = marker => {
      this.blockDragMarker = marker;
    };

    this.refreshCSS = () => {
      const isWebkit = 'WebkitAppearance' in document.documentElement.style;
      if (!isWebkit) {
        return;
      }
      // Must be body because we have several scrollcontainers loosing state
      const resetNode = document.body;
      resetNode.style.display = 'none';
      // eslint-disable-next-line no-unused-expressions
      resetNode.offsetHeight; // Looks weird, but it actually has an effect!
      resetNode.style.display = '';
    };

    this.handleEditorContainerClick = () => {
      this.editor.focus();
    };

    this.handleEditorFocus = event => {
      this.props.onFocus();
      this.setState({
        editorHasFocus: true
      });
    };

    this.handleEditorBlur = event => {
      this.setState({
        editorHasFocus: false
      });
    };

    this.handleInputScroll = event => {
      // Prevents the parent container to scroll when user tries
      // to scroll to the top/bottom of the block editor with momentum scroll or
      // a speedy mouse wheel
      // This makes the block-editor more usable when scrolling inside it.
      /*
      Enable this when activeOnFocus is finished
       const el = this._inputContainer
      const scrollTop = el.scrollTop
      const scrollHeight = el.scrollHeight
      const height = el.clientHeight
       if (this.state.fullscreen) {
        return
      }
       if (event.nativeEvent.deltaY <= 0) {
        // scrolling up
        if (scrollTop <= 0) {
          event.preventDefault()
        }
      } else if (scrollTop + height >= scrollHeight) {
        // scrolling down
        event.preventDefault()
      }
      */
    };

    this.setInputContainerElement = element => {
      this._inputContainer = element;
    };

    this.setEditorWrapper = element => {
      this._editorWrapper = element;
    };

    this.handleFullScreenScroll = event => {
      const threshold = 100;
      const scrollTop = event.target.scrollTop;
      let ratio = scrollTop / threshold;
      if (ratio >= 1) {
        ratio = 1;
      }
      this.setState({
        toolbarStyle: {
          backgroundColor: `rgba(255, 255, 255, ${ratio * 0.95})`,
          boxShadow: `0 2px ${5 * ratio}px rgba(0, 0, 0, ${ratio * 0.3})`
        }
      });
    };

    this.handleFullScreenClose = () => {
      this.setState({
        fullscreen: false
      });
    };

    const preparation = (0, _prepareSlateForBlockEditor2.default)(this);
    this.slateSchema = preparation.slateSchema;
    this.textStyles = preparation.textStyles;
    this.listItems = preparation.listItems;
    this.annotationTypes = preparation.annotationTypes;
    this.customBlocks = preparation.customBlocks;
    this.operations = (0, _createBlockEditorOperations2.default)(this);
    this.slatePlugins = (0, _initializeSlatePlugins2.default)(this);
  }

  componentDidMount() {
    window.addEventListener('keydown', this.handleKeyDown);
    // this._inputContainer.addEventListener('mousewheel', this.handleInputScroll)
    this.checkScrollHeight();
  }

  componentWillUnmount() {
    window.removeEventListener('keydown', this.handleKeyDown);
    // this._inputContainer.removeEventListener('mousewheel', this.handleInputScroll)
  }

  componentWillReceiveProps(nextProps) {
    if (nextProps !== this.props) {
      this.checkScrollHeight();
    }
  }

  hasAnnotationType(annotationType) {
    const value = this.props.value;

    const spans = value.inlines.filter(inline => inline.type == _constants.SLATE_SPAN_TYPE);
    return spans.some(span => {
      const annotations = span.data.get('annotations') || {};
      return Object.keys(annotations).find(key => annotations[key]._type === annotationType.name);
    });
  }

  getActiveAnnotations() {
    const value = this.props.value;
    const focusBlock = value.focusBlock;

    const disabled = value.inlines.some(inline => inline.type !== _constants.SLATE_SPAN_TYPE) || (focusBlock ? focusBlock.isVoid || focusBlock.text === '' : false);
    return this.annotationTypes.map(annotationType => {
      const active = this.hasAnnotationType(annotationType);
      return {
        active: active,
        type: annotationType,
        disabled: disabled
      };
    });
  }

  hasStyle(styleName) {
    const value = this.props.value;

    return value.blocks.some(block => block.data.get('style') === styleName);
  }

  getBlockStyles() {
    function Preview(props) {
      return _react2.default.createElement(
        'span',
        null,
        props.children
      );
    }

    const items = this.textStyles.map((style, index) => {
      return {
        key: `blockFormat-${index}`,
        style: style,
        preview: this.slateSchema.nodes.contentBlock({
          children: [_react2.default.createElement(
            Preview,
            { key: style.value, parent: { data: _slate.Data.create({ style: style.value }) } },
            style.title
          )]
        }),
        title: ` ${style.title}`,
        active: this.hasStyle(style.value)
      };
    });
    let value = items.filter(item => item.active);
    if (value.length === 0) {
      value = [{
        key: 'blockFormat-none',
        preview: null,
        type: null,
        title: 'No style',
        active: true
      }];
    }
    return {
      items: items,
      value: value
    };
  }

  hasDecorator(decoratorName) {
    const value = this.props.value;

    return value.marks.some(mark => mark.type == decoratorName);
  }

  getActiveDecorators() {
    return Object.keys(this.slateSchema.marks).map(decorator => {
      return {
        type: decorator,
        active: this.hasDecorator(decorator)
      };
    });
  }

  hasListItem(listItem) {
    const value = this.props.value;

    return value.blocks.some(block => {
      return block.data.get('listItem') === listItem;
    });
  }

  getListItems() {
    return this.listItems.map((item, index) => {
      return {
        type: item.value,
        title: item.title,
        active: this.hasListItem(item.value)
      };
    });
  }

  focus() {
    this.editor.focus();
  }

  // Webkit hack to force the browser to reapply CSS rules
  // This is needed to make ::before and ::after CSS rules work properly
  // under certain conditions (like the list counters for number lists)
  // http://stackoverflow.com/questions/3485365/how-can-i-force-webkit-to-redraw-repaint-to-propagate-style-changes/3485654#3485654


  showBlockDragMarker(pos, node) {
    this.blockDragMarker.style.display = 'block';
    const editorDOMNode = _reactDom2.default.findDOMNode(this.editor);
    const editorRect = editorDOMNode.getBoundingClientRect();
    const elemRect = node.getBoundingClientRect();
    const topPos = elemRect.top - editorRect.top;
    const bottomPos = topPos + (elemRect.bottom - elemRect.top);
    if (pos == 'after') {
      this.blockDragMarker.style.top = `${parseInt(bottomPos, 0)}px`;
    } else {
      this.blockDragMarker.style.top = `${parseInt(topPos, 0)}px`;
    }
  }

  hideBlockDragMarker() {
    this.blockDragMarker.style.display = 'none';
  }

  renderBlockEditor() {
    var _props = this.props;
    const value = _props.value,
          onChange = _props.onChange,
          readOnly = _props.readOnly;
    var _state = this.state;
    const fullscreen = _state.fullscreen,
          toolbarStyle = _state.toolbarStyle,
          preventScroll = _state.preventScroll,
          editorHasFocus = _state.editorHasFocus;


    return _react2.default.createElement(
      'div',
      { className: `${_BlockEditor2.default.root} ${fullscreen ? _BlockEditor2.default.fullscreen : ''}` },
      _react2.default.createElement(
        _activateOnFocus2.default,
        {
          isActive: editorHasFocus || fullscreen || !preventScroll,
          message: 'Click to edit'
        },
        !readOnly && _react2.default.createElement(_Toolbar2.default, {
          className: _BlockEditor2.default.toolbar,
          onInsertBlock: this.handleInsertBlock,
          insertBlocks: this.customBlocks,
          onFullscreenEnable: this.handleToggleFullscreen,
          fullscreen: this.state.fullscreen,
          onMarkButtonClick: this.handleOnClickMarkButton,
          onAnnotationButtonClick: this.handleAnnotationButtonClick,
          onListButtonClick: this.handleOnClickListFormattingButton,
          onBlockStyleChange: this.handleBlockStyleChange,
          listItems: this.getListItems(),
          blockStyles: this.getBlockStyles(),
          annotations: this.getActiveAnnotations(),
          decorators: this.getActiveDecorators(),
          style: toolbarStyle
        }),
        _react2.default.createElement(
          'div',
          {
            className: _BlockEditor2.default.inputContainer,
            id: this._inputId,
            onClick: this.handleEditorContainerClick,
            ref: this.setInputContainerElement,
            onWheel: this.handleInputScroll
          },
          _react2.default.createElement(
            'div',
            { ref: this.setEditorWrapper },
            _react2.default.createElement(_slateReact.Editor, {
              ref: this.refEditor,
              className: _BlockEditor2.default.input,
              onChange: readOnly ? NOOP : onChange,
              placeholder: '',
              readOnly: readOnly,
              state: value,
              blockEditor: this,
              plugins: this.slatePlugins,
              schema: this.slateSchema,
              onFocus: this.handleEditorFocus,
              onBlur: this.handleEditorBlur
            }),
            _react2.default.createElement('div', {
              ref: this.refBlockDragMarker,
              style: { display: 'none' },
              className: _BlockEditor2.default.blockDragMarker
            })
          )
        )
      )
    );
  }

  render() {
    var _props2 = this.props;
    const type = _props2.type,
          level = _props2.level,
          markers = _props2.markers;
    const fullscreen = this.state.fullscreen;

    const blockEditor = this.renderBlockEditor();

    return _react2.default.createElement(
      _default2.default,
      {
        markers: markers,
        label: type.title,
        description: type.description,
        labelFor: this._inputId,
        level: level
      },
      _react2.default.createElement(
        'button',
        {
          type: 'button',
          tabIndex: 0,
          className: _BlockEditor2.default.focusSkipper,
          onClick: () => this.focus()
        },
        'Jump to editor'
      ),
      fullscreen ? _react2.default.createElement(
        _fullscreen2.default,
        { isOpen: true, onClose: this.handleFullScreenClose },
        _react2.default.createElement(
          _scrollContainer2.default,
          { className: _BlockEditor2.default.portal, onScroll: this.handleFullScreenScroll },
          blockEditor
        )
      ) : blockEditor
    );
  }
}
exports.default = BlockEditor;
BlockEditor.propTypes = {
  type: _propTypes2.default.any,
  level: _propTypes2.default.number,
  value: _propTypes2.default.instanceOf(_slate.State),
  markers: _propTypes2.default.arrayOf(_propTypes2.default.shape({ type: _propTypes2.default.string.isRequired })),
  onChange: _propTypes2.default.func,
  onFocus: _propTypes2.default.func,
  readOnly: _propTypes2.default.bool,
  onNodePatch: _propTypes2.default.func
};
BlockEditor.defaultProps = {
  onChange() {},
  markers: []
};
BlockEditor.contextTypes = {
  formBuilder: _propTypes2.default.object
};