'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _default = require('part:@sanity/components/buttons/default');

var _default2 = _interopRequireDefault(_default);

var _popover = require('part:@sanity/components/dialogs/popover');

var _popover2 = _interopRequireDefault(_popover);

var _FormBuilderInput = require('../../FormBuilderInput');

var _FormBuilderSpan = require('./styles/FormBuilderSpan.css');

var _FormBuilderSpan2 = _interopRequireDefault(_FormBuilderSpan);

var _simplePatch = require('../../simplePatch');

var _StopPropagation = require('./StopPropagation');

var _StopPropagation2 = _interopRequireDefault(_StopPropagation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isEmpty(object, ignoreKeys) {
  for (const key in object) {
    if (!ignoreKeys.includes(key)) {
      return false;
    }
  }
  return true;
}

class FormBuilderSpan extends _react2.default.Component {
  constructor(...args) {
    var _temp;

    return _temp = super(...args), this.state = { isEditing: false, focusedAnnotationName: undefined }, this._clickCounter = 0, this._isMarkingText = false, this._editorNodeRect = null, this.destroy = () => {
      this.props.editor.props.blockEditor.operations.removeSpan(this.props.node);
    }, this.isEmptyAnnotation = annotation => {
      return isEmpty(annotation, ['_type', '_key']);
    }, this.handleCloseInput = () => {
      this.props.editor.focus();
      if (this.state.isEditing) {
        this.setState({ isEditing: false, focusedAnnotationName: undefined });
      }
      this.garbageCollect();
    }, this.handleMouseDown = () => {
      this._isMarkingText = true;
      setTimeout(() => {
        if (this._clickCounter === 1 && !this._isMarkingText) {
          this.setState({ isEditing: true });
        }
        this._clickCounter = 0;
      }, 350);
      this._clickCounter++;
    }, this.handleMouseUp = () => {
      this._isMarkingText = false;
    }, this.handleNodeClick = () => {
      const annotations = this.getAnnotations();
      // Don't do anyting if this type doesn't have annotations.
      if (this.props.type.annotations.length === 0) {
        return;
      }
      // Try to figure out which annotation that should be focused when user clicks the span
      let focusedAnnotationName;
      if (this.props.type.annotations.length === 1) {
        // Only one annotation type, always focus this one
        focusedAnnotationName = this.props.type.annotations[0].name;
      } else if (annotations && Object.keys(annotations).length === 1) {
        // Only one annotation value, focus it
        focusedAnnotationName = annotations[Object.keys(annotations)[0]]._type;
      }
      if (focusedAnnotationName) {
        this.focusAnnotation(focusedAnnotationName);
      }
      // If no focusedAnnotationName was found, buttons to edit respective annotations will be show
    }, this.handleAnnotationChange = event => {
      const name = this.state.focusedAnnotationName;
      const annotations = this.getAnnotations();
      const nextAnnotations = _extends({}, annotations, {
        [name]: (0, _simplePatch.applyAll)(annotations[name], event.patches)
      });
      Object.keys(nextAnnotations).forEach(key => {
        if (nextAnnotations[key] === undefined) {
          delete nextAnnotations[key];
        }
      });
      var _props = this.props;
      const node = _props.node,
            editor = _props.editor;

      const data = _extends({}, node.data.toObject(), {
        focusedAnnotationName: this.state.focusedAnnotationName,
        annotations: nextAnnotations
      });
      const change = editor.getState().change().setNodeByKey(node.key, { data });
      editor.onChange(change);
    }, this.setRootElement = element => {
      this.setState({ rootElement: element });
    }, _temp;
  }

  componentWillMount() {
    this.setState({
      isEditing: false,
      focusedAnnotationName: this.props.node.data && this.props.node.data.get('focusedAnnotationName')
    });
  }

  componentDidMount() {
    this._editorNodeRect = _reactDom2.default.findDOMNode(this.props.editor).getBoundingClientRect();
    if (this.state.focusedAnnotationName) {
      this.setState({ isEditing: true });
    }
  }

  shouldComponentUpdate(nextProps, nextState) {
    return nextState.isEditing !== this.state.isEditing || nextState.rootElement !== this.state.rootElement || nextState.focusedAnnotationName !== this.state.focusedAnnotationName || nextProps.state.focusOffset !== this.props.state.focusOffset || nextProps.node.data !== this.props.node.data;
  }

  componentWillUpdate(nextProps, nextState) {
    // If annotations where emptied, just destroy this span (unwrap it to text actually)
    if (!nextProps.node.data.get('annotations')) {
      this.destroy();
    }
  }

  componentDidUpdate() {
    // Close popover and clean up if it is unnanotated and no annotation type is in focus
    if (this.isUnannotated() && this.state.isEditing && !this.state.focusedAnnotationName) {
      this.handleCloseInput();
    }
  }

  isUnannotated() {
    const annotations = this.getAnnotations();
    if (!annotations) {
      return true;
    }
    return !Object.keys(annotations).filter(key => {
      return !this.isEmptyAnnotation(annotations[key]);
    }).length === 0;
  }

  getAnnotations() {
    return this.props.node.data.get('annotations');
  }

  garbageCollect() {
    let nextAnnotations = _extends({}, this.getAnnotations());
    Object.keys(nextAnnotations).forEach(key => {
      if (this.isEmptyAnnotation(nextAnnotations[key])) {
        delete nextAnnotations[key];
      }
    });
    var _props2 = this.props;
    const editor = _props2.editor,
          node = _props2.node;

    if (Object.keys(nextAnnotations).length === 0) {
      nextAnnotations = undefined;
    }
    const data = _extends({}, node.data.toObject(), {
      focusedAnnotationName: undefined,
      annotations: nextAnnotations
    });
    const change = editor.getState().change().setNodeByKey(node.key, { data });

    editor.onChange(change);
  }

  focusAnnotation(annotationName) {
    var _props3 = this.props;
    const editor = _props3.editor,
          node = _props3.node;

    this.setState({ focusedAnnotationName: annotationName });
    const data = _extends({}, node.data.toObject(), {
      focusedAnnotationName: annotationName
    });
    const change = editor.getState().change().setNodeByKey(node.key, { data });
    editor.onChange(change);
  }

  // Open dialog when user clicks the node,
  // but support double clicks, and mark text as normal


  renderInput() {
    const annotations = this.getAnnotations();
    const annotationTypes = this.props.type.annotations;
    const focusedAnnotationName = this.state.focusedAnnotationName;


    const annotationTypeInFocus = annotationTypes.find(type => {
      return type.name === focusedAnnotationName;
    });
    const focusedAnnotationKey = Object.keys(annotations).find(key => {
      return annotations[key]._type === focusedAnnotationName;
    });
    const annotationValue = focusedAnnotationKey && annotations && annotations[focusedAnnotationKey];
    return _react2.default.createElement(
      'span',
      { className: _FormBuilderSpan2.default.editSpanContainer },
      _react2.default.createElement(
        _popover2.default,
        {
          onClose: this.handleCloseInput,
          onEscape: this.handleCloseInput,
          onClickOutside: this.handleCloseInput,
          modifiers: {
            flip: {
              boundariesElement: 'scrollParent'
            },
            preventOverflow: {
              boundariesElement: 'scrollParent'
            }
          }
        },
        !focusedAnnotationName && Object.keys(annotations).length > 1 && _react2.default.createElement(
          'div',
          null,
          _react2.default.createElement(
            'h3',
            null,
            'Which annotation?'
          ),
          Object.keys(annotations).map(annotationKey => {
            if (!annotations[annotationKey]) {
              return null;
            }
            const setFieldFunc = () => {
              this.focusAnnotation(annotations[annotationKey]._type);
            };
            return _react2.default.createElement(
              _default2.default,
              { key: `annotationButton${annotationKey}`, onClick: setFieldFunc },
              annotationTypes.find(type => type.name === annotations[annotationKey]._type).title
            );
          })
        ),
        focusedAnnotationName && _react2.default.createElement(
          'div',
          null,
          _react2.default.createElement(_FormBuilderInput.FormBuilderInput, {
            value: annotationValue,
            type: annotationTypeInFocus,
            level: 0,
            onChange: this.handleAnnotationChange,
            autoFocus: true
          })
        )
      )
    );
  }

  render() {
    const isEditing = this.state.isEditing;
    const attributes = this.props.attributes;

    return _react2.default.createElement(
      'span',
      _extends({}, attributes, { className: _FormBuilderSpan2.default.root, ref: this.setRootElement }),
      _react2.default.createElement(
        'span',
        {
          onClick: this.handleNodeClick,
          onMouseDown: this.handleMouseDown,
          onMouseUp: this.handleMouseUp
        },
        this.props.children
      ),
      isEditing && _react2.default.createElement(
        _StopPropagation2.default,
        { tagName: 'span' },
        this.renderInput()
      )
    );
  }
}
exports.default = FormBuilderSpan;
FormBuilderSpan.propTypes = {
  type: _propTypes2.default.object,
  editor: _propTypes2.default.object,
  state: _propTypes2.default.object,
  attributes: _propTypes2.default.object,
  children: _propTypes2.default.node,
  node: _propTypes2.default.object
};