'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _offsetKey = require('slate-react/lib/utils/offset-key');

var _offsetKey2 = _interopRequireDefault(_offsetKey);

var _setTransferData = require('slate-react/lib/utils/set-transfer-data');

var _setTransferData2 = _interopRequireDefault(_setTransferData);

var _transferTypes = require('slate-react/lib/constants/transfer-types');

var _transferTypes2 = _interopRequireDefault(_transferTypes);

var _slateBase64Serializer = require('slate-base64-serializer');

var _slateBase64Serializer2 = _interopRequireDefault(_slateBase64Serializer);

var _slate = require('slate');

var _ItemForm = require('./ItemForm');

var _ItemForm2 = _interopRequireDefault(_ItemForm);

var _popover = require('part:@sanity/components/dialogs/popover');

var _popover2 = _interopRequireDefault(_popover);

var _Preview = require('../../Preview');

var _Preview2 = _interopRequireDefault(_Preview);

var _FormBuilderInline = require('./styles/FormBuilderInline.css');

var _FormBuilderInline2 = _interopRequireDefault(_FormBuilderInline);

var _createRange = require('./util/createRange');

var _createRange2 = _interopRequireDefault(_createRange);

var _simplePatch = require('../../simplePatch');

var _resolveTypeName = require('../../utils/resolveTypeName');

var _InvalidValueInput = require('../InvalidValueInput');

var _InvalidValueInput2 = _interopRequireDefault(_InvalidValueInput);

var _StopPropagation = require('./StopPropagation');

var _StopPropagation2 = _interopRequireDefault(_StopPropagation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class FormBuilderInline extends _react2.default.Component {
  constructor(...args) {
    var _temp;

    return _temp = super(...args), this.state = {
      isSelected: false,
      isEditing: false,
      isDragging: false
    }, this._dropTarget = null, this._editorNode = null, this.handleChange = event => {
      var _props = this.props;
      const onPatch = _props.onPatch,
            node = _props.node;

      onPatch(event.prefixAll(node.key));
    }, this.handleInvalidValueChange = event => {
      var _props2 = this.props;
      const onPatch = _props2.onPatch,
            node = _props2.node;

      onPatch(event.prefixAll(node.key));
    }, this.handleDragStart = event => {
      const editor = this.props.editor;

      this._editorNode = _reactDom2.default.findDOMNode(editor);

      this.setState({ isDragging: true });
      this.addDragHandlers();

      const element = _reactDom2.default.findDOMNode(this.previewContainer);
      const encoded = _slateBase64Serializer2.default.serializeNode(this.props.node, { preserveKeys: true });
      (0, _setTransferData2.default)(event.dataTransfer, _transferTypes2.default.NODE, encoded);
      event.dataTransfer.effectAllowed = 'move';
      event.dataTransfer.setDragImage(element, element.clientWidth / 2, -10);
    }, this.handleSelectionChange = event => {
      if (!this._editorNode || !this._editorNode.contains(event.target)) {
        return;
      }
      const selection = document.getSelection();
      const isSelected = selection.containsNode && selection.containsNode(this.formBuilderInline);
      this.setState({ isSelected });
    }, this.handleDragLeave = event => {
      if (event.target === this._editorNode) {
        this._dropTarget = null;
      }
    }, this.handleDragOverOtherNode = event => {
      if (!this.state.isDragging) {
        return;
      }

      const targetDOMNode = event.target;

      // As the event is registered on the editor parent node
      // ignore the event if it is coming from from the editor node itself
      if (targetDOMNode === this._editorNode) {
        this._dropTarget = null;
        return;
      }

      const offsetKey = _offsetKey2.default.findKey(targetDOMNode, 0);
      if (!offsetKey) {
        return;
      }
      const key = offsetKey.key;

      // If this is 'our' node, return

      if (this.props.node.hasDescendant(key)) {
        return;
      }

      const editor = this.props.editor;

      const state = editor.getState();
      const document = state.document;


      const range = (0, _createRange2.default)(event);

      if (range === null) {
        return;
      }

      const rangeOffset = range.rangeOffset;


      const node = document.getDescendant(key);

      if (!node) {
        this._dropTarget = null;
        return;
      }

      // If we are dragging over a custom type block return
      const block = document.getClosestBlock(node.key);
      if (block && block.type !== 'contentBlock') {
        return;
      }

      // If we are dragging over another inline return
      if (document.getClosestInline(node.key)) {
        return;
      }

      this._dropTarget = { node: node, offset: rangeOffset };
      this.moveCursor(rangeOffset, node);
    }, this.handleDragEnd = event => {
      this.setState({ isDragging: false });
      this.removeDragHandlers();

      if (!this._dropTarget) {
        return;
      }

      var _props3 = this.props;
      const editor = _props3.editor,
            node = _props3.node;

      const state = editor.getState();
      const change = state.change().removeNodeByKey(node.key).insertInline(node).focus();
      this._dropTarget = null;
      editor.onChange(change);
    }, this.handleCancelEvent = event => {
      event.preventDefault();
    }, this.handleToggleEdit = () => {
      this.setState({ isEditing: true });
    }, this.handleClose = () => {
      this.setState({ isEditing: false });
    }, this.refFormBuilderInline = formBuilderInline => {
      this.formBuilderInline = formBuilderInline;
    }, this.refPreview = previewContainer => {
      this.previewContainer = previewContainer;
    }, this.handleDialogAction = action => {
      if (action.name === 'close') {
        this.handleClose();
      }
    }, _temp;
  }

  componentDidMount() {
    this.addSelectionHandler();
  }

  componentWillUnmount() {
    this.removeSelectionHandler();
  }

  addSelectionHandler() {
    document.addEventListener('selectionchange', this.handleSelectionChange);
  }

  removeSelectionHandler() {
    document.removeEventListener('selectionchange', this.handleSelectionChange);
  }

  addDragHandlers() {
    this._editorNode.addEventListener('dragover', this.handleDragOverOtherNode);
    this._editorNode.addEventListener('dragleave', this.handleDragLeave);
  }

  removeDragHandlers() {
    this._editorNode.removeEventListener('dragover', this.handleDragOverOtherNode);
    this._editorNode.removeEventListener('dragleave', this.handleDragLeave);
  }

  // Remove the drop target if we leave the editors nodes


  getValue() {
    return this.props.node.data.get('value');
  }

  getMemberTypeOf(value) {
    const typeName = (0, _resolveTypeName.resolveTypeName)(value);
    return this.props.type.of.find(memberType => memberType.name === typeName);
  }

  renderPreview() {
    const value = this.getValue();
    const memberType = this.getMemberTypeOf(value);
    if (!memberType) {
      const validMemberTypes = this.props.type.of.map(type => type.name);
      const actualType = (0, _resolveTypeName.resolveTypeName)(value);
      return _react2.default.createElement(_InvalidValueInput2.default, {
        validTypes: validMemberTypes,
        actualType: actualType,
        value: value,
        onChange: this.handleInvalidValueChange
      });
    }
    return _react2.default.createElement(
      'span',
      null,
      _react2.default.createElement(_Preview2.default, { type: memberType, value: this.getValue(), layout: 'inline' })
    );
  }

  renderInput() {
    const value = this.getValue();
    const memberType = this.getMemberTypeOf(value);

    return _react2.default.createElement(
      _popover2.default,
      {
        title: this.props.node.title,
        onClose: this.handleClose,
        onClickOutside: this.handleClose,
        onEscape: this.handleClose,
        onAction: this.handleDialogAction,
        modifiers: {
          flip: {
            boundariesElement: 'viewport'
          },
          preventOverflow: {
            priority: ['bottom', 'top', 'right', 'left'],
            boundariesElement: 'viewport'
          }
        },
        showCloseButton: false,
        actions: [{
          index: '1',
          name: 'close',
          title: 'Close'
        }]
      },
      _react2.default.createElement(
        'div',
        { style: { padding: '1rem' } },
        _react2.default.createElement(_ItemForm2.default, {
          onDrop: this.handleCancelEvent,
          type: memberType,
          level: 0,
          value: this.getValue(),
          onChange: this.handleChange
        })
      )
    );
  }

  moveCursor(offset, node) {
    if (node.kind !== 'text') {
      return;
    }
    const editor = this.props.editor;

    const state = editor.getState();
    const document = state.document;

    let theOffset = offset;

    // Check if it is acceptable to move the cursor here
    const nextChars = document.getCharactersAtRange(_slate.Selection.create({
      anchorKey: node.key,
      focusKey: node.key,
      anchorOffset: offset - 1,
      focusOffset: offset,
      isFocused: true,
      isBackward: false
    }));
    if (!nextChars.size) {
      theOffset = 0;
    }

    const change = state.change().collapseToStartOf(node).move(theOffset).focus();
    editor.onChange(change);
  }

  render() {
    const isEditing = this.state.isEditing;
    const attributes = this.props.attributes;
    var _props4 = this.props;
    const node = _props4.node,
          editor = _props4.editor;

    const isFocused = editor.props.blockEditor.props.value.selection.hasFocusIn(node);

    let className;
    if (isFocused && !this.state.isSelected) {
      className = _FormBuilderInline2.default.focused;
    } else if (this.state.isSelected) {
      className = _FormBuilderInline2.default.selected;
    } else {
      className = _FormBuilderInline2.default.root;
    }

    return _react2.default.createElement(
      'span',
      _extends({}, attributes, {
        onDragStart: this.handleDragStart,
        onDragEnd: this.handleDragEnd,
        onDragEnter: this.handleCancelEvent,
        onDragLeave: this.handleCancelEvent,
        onDrop: this.handleCancelEvent,
        draggable: true,
        ref: this.refFormBuilderInline,
        className: className
      }),
      _react2.default.createElement(
        'span',
        {
          ref: this.refPreview,
          className: _FormBuilderInline2.default.previewContainer,
          onClick: this.handleToggleEdit
        },
        this.renderPreview()
      ),
      isEditing && _react2.default.createElement(
        'span',
        { className: _FormBuilderInline2.default.editInlineContainer },
        _react2.default.createElement(
          _StopPropagation2.default,
          { tagName: 'span' },
          this.renderInput()
        )
      )
    );
  }
}
exports.default = FormBuilderInline;
FormBuilderInline.propTypes = {
  // Note: type refers to the array type, not the value type
  type: _propTypes2.default.object,
  node: _propTypes2.default.object,
  editor: _propTypes2.default.object,
  state: _propTypes2.default.object,
  attributes: _propTypes2.default.object,
  onPatch: _propTypes2.default.func
};