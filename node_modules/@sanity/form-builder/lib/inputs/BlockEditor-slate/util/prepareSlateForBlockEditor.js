'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

// Preview components of different text types


exports.default = prepareSlateForBlockEditor;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _slate = require('slate');

var _createBlockNode = require('../createBlockNode');

var _createBlockNode2 = _interopRequireDefault(_createBlockNode);

var _createInlineNode = require('../createInlineNode');

var _createInlineNode2 = _interopRequireDefault(_createInlineNode);

var _createSpanNode = require('../createSpanNode');

var _createSpanNode2 = _interopRequireDefault(_createSpanNode);

var _mapToObject = require('./mapToObject');

var _mapToObject2 = _interopRequireDefault(_mapToObject);

var _randomKey = require('../util/randomKey');

var _randomKey2 = _interopRequireDefault(_randomKey);

var _spanHelpers = require('./spanHelpers');

var _constants = require('../constants');

var _Blockquote = require('../preview/Blockquote');

var _Blockquote2 = _interopRequireDefault(_Blockquote);

var _Header = require('../preview/Header');

var _Header2 = _interopRequireDefault(_Header);

var _ListItem = require('../preview/ListItem');

var _ListItem2 = _interopRequireDefault(_ListItem);

var _Decorator = require('../preview/Decorator');

var _Decorator2 = _interopRequireDefault(_Decorator);

var _Normal = require('../preview/Normal');

var _Normal2 = _interopRequireDefault(_Normal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Set our own key generator for Slate
const keyGenerator = () => (0, _randomKey2.default)(12);
(0, _slate.setKeyGenerator)(keyGenerator);

// When the slate-fields are rendered in the editor, their node data is stored in a parent container component.
// In order to use the node data as props inside our components, we have to dereference them here first (see list and header keys)
const slateTypeComponentMapping = {
  normal: _Normal2.default,
  h1(props) {
    return _react2.default.createElement(_Header2.default, _extends({ level: 1 }, props));
  },
  h2(props) {
    // eslint-disable-line react/no-multi-comp
    return _react2.default.createElement(_Header2.default, _extends({ level: 2 }, props));
  },
  h3(props) {
    // eslint-disable-line react/no-multi-comp
    return _react2.default.createElement(_Header2.default, _extends({ level: 3 }, props));
  },
  h4(props) {
    // eslint-disable-line react/no-multi-comp
    return _react2.default.createElement(_Header2.default, _extends({ level: 4 }, props));
  },
  h5(props) {
    // eslint-disable-line react/no-multi-comp
    return _react2.default.createElement(_Header2.default, _extends({ level: 5 }, props));
  },
  h6(props) {
    // eslint-disable-line react/no-multi-comp
    return _react2.default.createElement(_Header2.default, _extends({ level: 6 }, props));
  },
  listItem(props) {
    // eslint-disable-line react/no-multi-comp
    // eslint-disable-next-line react/prop-types
    const listItem = props.children[0] && props.children[0].props.parent.data.get('listItem');
    // eslint-disable-next-line react/prop-types
    const level = props.children[0] && props.children[0].props.parent.data.get('level');
    // eslint-disable-next-line react/prop-types
    const style = props.children[0] && props.children[0].props.parent.data.get('style') || _constants.BLOCK_DEFAULT_STYLE;
    const contentComponent = slateTypeComponentMapping[style];
    return _react2.default.createElement(_ListItem2.default, _extends({ contentComponent: contentComponent, level: level, listItem: listItem }, props));
  },
  blockquote: _Blockquote2.default

  // Create a contentBlock component
};function createContentBlock(props) {
  let component = null;
  const style = props.children[0] && props.children[0].props.parent.data.get('style');
  const isListItem = props.children[0] && props.children[0].props.parent.data.get('listItem');
  if (isListItem) {
    component = slateTypeComponentMapping.listItem;
  } else {
    component = slateTypeComponentMapping[style];
  }
  if (!component) {
    // eslint-disable-next-line no-console
    console.warn(`No mapping for style '${style}' exists, using 'normal'`);
    component = slateTypeComponentMapping.normal;
  }
  return component(props);
}

function prepareSlateForBlockEditor(blockEditor) {
  const type = blockEditor.props.type;
  const blockType = type.of.find(ofType => ofType.name === 'block');
  if (!blockType) {
    throw new Error("'block' type is not defined in the schema (required).");
  }

  const styleField = blockType.fields.find(btField => btField.name === 'style');
  if (!styleField) {
    throw new Error("A field with name 'style' is not defined in the block type (required).");
  }

  const textStyles = styleField.type.options.list && styleField.type.options.list.filter(style => style.value);
  if (!textStyles || textStyles.length === 0) {
    throw new Error('The style fields need at least one style ' + "defined. I.e: {title: 'Normal', value: 'normal'}.");
  }

  const listField = blockType.fields.find(btField => btField.name === 'list');
  let listItems = [];
  if (listField) {
    listItems = listField.type.options.list && listField.type.options.list.filter(listStyle => listStyle.value);
  }

  const memberTypesExceptBlock = type.of.filter(ofType => ofType.name !== 'block');
  const spanType = (0, _spanHelpers.getSpanType)(type);
  const allowedDecorators = spanType.decorators.map(decorator => decorator.value);

  const FormBuilderBlock = (0, _createBlockNode2.default)(type, blockEditor.handleNodePatch);
  const FormBuilderInline = (0, _createInlineNode2.default)(type, blockEditor.handleNodePatch);

  const slateSchema = {
    nodes: _extends({}, (0, _mapToObject2.default)(memberTypesExceptBlock, ofType => [ofType.name, ofType.options && ofType.options.inline ? FormBuilderInline : FormBuilderBlock]), {
      __unknown: FormBuilderBlock,
      span: (0, _createSpanNode2.default)(spanType),
      contentBlock: createContentBlock
    }),
    marks: (0, _mapToObject2.default)(allowedDecorators, decorator => {
      return [decorator, _Decorator2.default];
    }),
    rules: [
    // Rule to insert a default block when document is empty,
    // or only contains one empty contentBlock
    {
      match: node => {
        return node.kind === 'document';
      },
      validate: document => {
        return document.nodes.size === 0 || document.nodes.size === 1 && document.nodes.first().type === _constants.SLATE_DEFAULT_BLOCK.type && document.nodes.first().text === '' && document.nodes.first().data.get('style') !== _constants.BLOCK_DEFAULT_STYLE ? document : null;
      },
      normalize: (change, document) => {
        change.deselect();
        const hasEmptySingleContentBlock = document.nodes.size === 1;
        change.insertNodeByKey(document.key, 0, _slate.Block.create(_constants.SLATE_DEFAULT_BLOCK));
        if (hasEmptySingleContentBlock) {
          change.removeNodeByKey(document.nodes.first().key);
        }
        return change.collapseToStartOf(change.state.document.nodes.first()).focus();
      }
    },
    // Rule to ensure that every non-void block has a style
    {
      match: node => {
        if (node.kind === 'block' && !node.isVoid) {
          return node;
        }
        return undefined;
      },
      validate: block => {
        return block.data.get('style') === undefined ? block : null;
      },
      normalize: (change, block) => {
        const data = _extends({}, block.data.toObject(), { style: _constants.BLOCK_DEFAULT_STYLE });
        return change.setNodeByKey(block.key, { data });
      }
    },
    // Rule to ensure that annotation _key's within a block is unique
    // Duplication can happen when copy/pasting annotation spans within the same block
    {
      match: node => {
        // contentBlock with annotations
        return node.kind === 'block' && node.type === 'contentBlock' && node.filterDescendants(desc => {
          const annotations = desc.data && desc.data.get('annotations');
          return annotations && Object.keys(annotations).length;
        }).size;
      },

      validate: contentBlock => {
        // return the last occurence of nodes with annotations that has the same _key
        const duplicateKeyNodes = contentBlock.filterDescendants(desc => desc.data && desc.data.get('annotations')).toArray().map(aNode => {
          const annotations = aNode.data.get('annotations');
          return Object.keys(annotations).map(name => annotations[name]._key);
        }).reduce((a, b) => {
          return a.concat(b);
        }, []).filter((key, i, keys) => keys.lastIndexOf(key) !== i);
        if (duplicateKeyNodes.length) {
          return duplicateKeyNodes.map(key => {
            return {
              dupKey: key,
              dupNode: contentBlock.filterDescendants(desc => {
                const annotations = desc.data && desc.data.get('annotations');
                return annotations && Object.keys(annotations).find(name => annotations[name]._key === key);
              }).toArray().slice(-1)[0] // Last occurence
            };
          });
        }
        return null;
      },
      normalize: (change, node, dupNodes) => {
        dupNodes.forEach(dup => {
          const dupKey = dup.dupKey,
                dupNode = dup.dupNode;

          const annotations = _extends({}, dupNode.data.get('annotations'));
          const newAnnotations = {};
          Object.keys(annotations).forEach(name => {
            newAnnotations[name] = _extends({}, annotations[name]);
            if (annotations[name]._key === dupKey) {
              newAnnotations[name]._key = (0, _randomKey2.default)(12);
            }
          });
          const data = _extends({}, dupNode.data.toObject(), { annotations: newAnnotations });
          change.setNodeByKey(dupNode.key, { data });
        });
        return change;
      }
    }]
  };
  return {
    listItems: listItems,
    textStyles: textStyles,
    annotationTypes: spanType.annotations,
    decorators: spanType.decorators,
    customBlocks: memberTypesExceptBlock,
    slateSchema: slateSchema
  };
}