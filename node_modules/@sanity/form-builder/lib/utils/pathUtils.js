'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isEqual = isEqual;
exports.isSegmentEqual = isSegmentEqual;
exports.hasFocus = hasFocus;
exports.hasItemFocus = hasItemFocus;
exports.isExpanded = isExpanded;
exports.startsWith = startsWith;
exports.trimLeft = trimLeft;
exports.trimRight = trimRight;
exports.toString = toString;

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

/*:: import type {Path, PathSegment} from '../typedefs/path'*/
function isEqual(path /*: Path*/, otherPath /*: Path*/) {
  return path.length === otherPath.length && path.every((segment, i) => isSegmentEqual(segment, otherPath[i]));
}

const FOCUS_TERMINATOR = exports.FOCUS_TERMINATOR = '$';

function isSegmentEqual(pathSegment /*: PathSegment*/, otherPathSegment /*: PathSegment*/) {
  const pathSegmentType = typeof pathSegment;
  const otherPathSegmentType = typeof otherPathSegment;
  if (pathSegmentType !== otherPathSegmentType) {
    return false;
  }
  if (pathSegmentType === 'string' || pathSegmentType === 'number') {
    return pathSegment === otherPathSegment;
  }
  if (!pathSegment || !otherPathSegment) {
    return false;
  }
  return pathSegment._key === otherPathSegment._key;
}

function hasFocus(focusPath /*: Path*/, path /*: Path*/) /*: boolean*/ {
  const _withoutFirst = focusPath[focusPath.length - 1] === FOCUS_TERMINATOR ? focusPath.slice(0, -1) : focusPath;
  return isEqual(_withoutFirst, path);
}

function hasItemFocus(focusPath /*: Path*/, item /*: Path*/) /*: boolean*/ {
  return focusPath.length === 1 && isSegmentEqual(focusPath[0], item);
}

function isExpanded(segment /*: PathSegment*/, focusPath /*: Path*/) /*: boolean*/ {
  var _focusPath = _toArray(focusPath);

  const head = _focusPath[0],
        tail = _focusPath.slice(1);

  return tail.length > 0 && isSegmentEqual(segment, head);
}

function startsWith(prefix /*: Path*/, path /*: Path*/) /*: boolean*/ {
  return prefix.every((segment, i) => isSegmentEqual(segment, path[i]));
}

function trimLeft(prefix /*: Path*/, path /*: Path*/) /*: Path*/ {
  if (prefix.length === 0 || path.length === 0) {
    return path;
  }

  var _prefix = _toArray(prefix);

  const prefixHead = _prefix[0],
        prefixTail = _prefix.slice(1);

  var _path = _toArray(path);

  const pathHead = _path[0],
        pathTail = _path.slice(1);

  if (!isSegmentEqual(prefixHead, pathHead)) {
    return path;
  }
  return trimLeft(prefixTail, pathTail);
}

function trimRight(suffix, path) {
  const sufLen = suffix.length;
  const pathLen = path.length;
  if (sufLen === 0 || pathLen === 0) {
    return path;
  }

  let i = 0;
  while (i < sufLen && i < pathLen && isSegmentEqual(path[pathLen - i - 1], suffix[sufLen - i - 1])) {
    i++;
  }

  return path.slice(0, pathLen - i);
}

function toString(path) {
  return path.reduce((target, segment, i) => {
    const segmentType = typeof segment;
    if (segmentType === 'number') {
      return `${target}[${segment}]`;
    }

    if (segmentType === 'string') {
      const separator = i === 0 ? '' : '.';
      return `${target}${separator}${segment}`;
    }

    if (segment._key) {
      return `${target}[_key=="${segment._key}"]`;
    }

    throw new Error(`Unsupported path segment "${segment}"`);
  }, '');
}