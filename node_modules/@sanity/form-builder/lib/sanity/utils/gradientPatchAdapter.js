'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _flatten2 = require('lodash/flatten');

var _flatten3 = _interopRequireDefault(_flatten2);

exports.toGradient = toGradient;
exports.toFormBuilder = toFormBuilder;

var _mutator = require('@sanity/mutator');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _convertPath = require('./convertPath');

var convertPath = _interopRequireWildcard(_convertPath);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*:: import type {Origin, Patch} from '../../typedefs/patch'*/
/*:: type GradientPatch = Object*/
function toGradient(patches /*: Patch[]*/) /*: GradientPatch[]*/ {
  return patches.map(toGradientPatch);
}

function toFormBuilder(origin /*: Origin*/, patches /*: GradientPatch[]*/) /*: Patch[]*/ {
  return (0, _flatten3.default)(patches.map(patch => toFormBuilderPatch(origin, patch)));
}

const notIn = values => value => !values.includes(value);

function toFormBuilderPatch(origin /*: Origin*/, patch /*: GradientPatch*/) /*: Patch*/ {
  return (0, _flatten3.default)(Object.keys(patch).filter(notIn(['id', 'ifRevisionID', 'query'])).map(type => {
    if (type === 'unset') {
      return patch.unset.map(path => {
        return {
          type: 'unset',
          path: convertPath.toFormBuilder(path),
          origin
        };
      });
    }
    return Object.keys(patch[type]).map(gradientPath => {
      if (type === 'insert') {
        const position = 'before' in patch.insert ? 'before' : 'after';
        return {
          type: 'insert',
          position: position,
          path: convertPath.toFormBuilder(patch.insert[position]),
          items: patch.insert.items,
          origin
        };
      }
      if (type === 'set') {
        return {
          type: 'set',
          path: convertPath.toFormBuilder(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      }
      if (type === 'inc' || type === 'dec') {
        return {
          type: type,
          path: convertPath.toFormBuilder(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      }
      if (type === 'setIfMissing') {
        return {
          type: 'setIfMissing',
          path: convertPath.toFormBuilder(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      }
      if (type === 'diffMatchPatch') {
        return {
          type: 'diffMatchPatch',
          path: convertPath.toFormBuilder(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      }
      console.warn(new Error(`Unsupported patch type: ${type}`));
      return null;
    }).filter(Boolean);
  }));
}

function toGradientPatch(patch /*: Patch*/) /*: GradientPatch*/ {
  const matchPath = (0, _mutator.arrayToJSONMatchPath)(patch.path || []);
  if (patch.type === 'insert') {
    const position = patch.position,
          items = patch.items;

    return {
      insert: {
        [position]: matchPath,
        items: items
      }
    };
  }

  if (patch.type === 'unset') {
    return {
      unset: [matchPath]
    };
  }

  (0, _assert2.default)(patch.type, `Missing patch type in patch ${JSON.stringify(patch)}`);
  if (matchPath) {
    return {
      [patch.type]: {
        [matchPath]: patch.value
      }
    };
  }
  return {
    [patch.type]: patch.value
  };
}