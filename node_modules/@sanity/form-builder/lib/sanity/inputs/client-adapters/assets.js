'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.uploadFileAsset = exports.uploadImageAsset = undefined;
exports.materializeReference = materializeReference;

var _client = require('part:@sanity/base/client');

var _client2 = _interopRequireDefault(_client);

var _preview = require('part:@sanity/base/preview');

var _withMaxConcurrency = require('../../utils/withMaxConcurrency');

var _observable = require('@sanity/observable');

var _observable2 = _interopRequireDefault(_observable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const MAX_CONCURRENT_UPLOADS = 4;

function uploadSanityAsset(assetType, file) {
  return _observable2.default.from(hashFile(file)).catch(error =>
  // ignore if hashing fails for some reason
  _observable2.default.of(null)).mergeMap(hash => hash ? fetchExisting(`sanity.${assetType}Asset`, hash) : _observable2.default.of(null)).mergeMap(existing => {
    if (existing) {
      return _observable2.default.of({
        // complete with the existing asset document
        type: 'complete',
        id: existing._id,
        asset: existing
      });
    }
    return _client2.default.observable.assets.upload(assetType, file).map(event => event.type === 'response' ? {
      // rewrite to a 'complete' event
      type: 'complete',
      id: event.body.document._id,
      asset: event.body.document
    } : event);
  });
}

const uploadAsset = (0, _withMaxConcurrency.withMaxConcurrency)(uploadSanityAsset, MAX_CONCURRENT_UPLOADS);

const uploadImageAsset = exports.uploadImageAsset = file => uploadAsset('image', file);
const uploadFileAsset = exports.uploadFileAsset = file => uploadAsset('file', file);

function materializeReference(id) {
  return (0, _preview.observePaths)(id, ['originalFilename', 'url', 'metadata']);
}

function fetchExisting(type, hash) {
  return _client2.default.observable.fetch('*[_type == $documentType && sha1hash == $hash][0]', {
    documentType: type,
    hash
  });
}

function readFile(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsArrayBuffer(file);
  });
}

function hashFile(file) {
  if (!window.crypto || !window.crypto.subtle || !window.FileReader) {
    return Promise.resolve(null);
  }
  return readFile(file).then(arrayBuffer => crypto.subtle.digest('SHA-1', arrayBuffer)).then(hexFromBuffer);
}

function hexFromBuffer(buffer) {
  return Array.prototype.map.call(new Uint8Array(buffer), x => `00${x.toString(16)}`.slice(-2)).join('');
}