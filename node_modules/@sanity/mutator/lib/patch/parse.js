'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parse;

var _SetPatch = require('./SetPatch');

var _SetPatch2 = _interopRequireDefault(_SetPatch);

var _IncPatch = require('./IncPatch');

var _IncPatch2 = _interopRequireDefault(_IncPatch);

var _InsertPatch = require('./InsertPatch');

var _InsertPatch2 = _interopRequireDefault(_InsertPatch);

var _SetIfMissingPatch = require('./SetIfMissingPatch');

var _SetIfMissingPatch2 = _interopRequireDefault(_SetIfMissingPatch);

var _UnsetPatch = require('./UnsetPatch');

var _UnsetPatch2 = _interopRequireDefault(_UnsetPatch);

var _DiffMatchPatch = require('./DiffMatchPatch');

var _DiffMatchPatch2 = _interopRequireDefault(_DiffMatchPatch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Parses a Gradient patch into our own personal patch implementations
function parse(patch /*: Object*/) /*: Array<Object>*/ {
  const result = [];
  if (Array.isArray(patch)) {
    return patch.reduce((r, p) => r.concat(parse(p)), result);
  }
  if (patch.set) {
    Object.keys(patch.set).forEach(path => {
      result.push(new _SetPatch2.default(patch.id, path, patch.set[path]));
    });
  }
  if (patch.setIfMissing) {
    Object.keys(patch.setIfMissing).forEach(path => {
      result.push(new _SetIfMissingPatch2.default(patch.id, path, patch.setIfMissing[path]));
    });
  }
  // TODO: merge
  if (patch.unset) {
    patch.unset.forEach(path => {
      result.push(new _UnsetPatch2.default(patch.id, path));
    });
  }
  if (patch.diffMatchPatch) {
    Object.keys(patch.diffMatchPatch).forEach(path => {
      result.push(new _DiffMatchPatch2.default(patch.id, path, patch.diffMatchPatch[path]));
    });
  }
  if (patch.inc) {
    Object.keys(patch.inc).forEach(path => {
      result.push(new _IncPatch2.default(patch.id, path, patch.inc[path]));
    });
  }
  if (patch.dec) {
    Object.keys(patch.dec).forEach(path => {
      result.push(new _IncPatch2.default(patch.id, path, -patch.dec[path]));
    });
  }
  if (patch.insert) {
    let location /*: string*/;
    let path /*: string*/;
    const spec = patch.insert;
    if (spec.before) {
      location = 'before';
      path = spec.before;
    } else if (spec.after) {
      location = 'after';
      path = spec.after;
    } else if (spec.replace) {
      location = 'replace';
      path = spec.replace;
    }
    result.push(new _InsertPatch2.default(patch.id, location, path, spec.items));
  }
  return result;
}