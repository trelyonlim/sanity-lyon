'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const Type = require('type-of-is');

var _require = require('lodash');

const flatten = _require.flatten;

const ValidationError = require('./ValidationError');

/* eslint-disable no-console */
module.exports = (() => {
  var _ref = _asyncToGenerator(function* (doc, schema) {
    const documentType = schema.get(doc._type);
    if (!documentType) {
      console.warn('Schema type for object type "%s" not found, skipping validation', doc._type);
      return [];
    }

    try {
      return yield validateItem(doc, documentType, [], { document: doc });
    } catch (err) {
      console.error(err);
      return [{ type: 'validation', level: 'error', path: [], item: new ValidationError(err.message) }];
    }
  });

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();

function validateItem(item, type, path, options) {
  if (Array.isArray(item)) {
    return validateArray(item, type, path, options);
  }

  if (typeof item === 'object') {
    return validateObject(item, type, path, options);
  }

  return validatePrimitive(item, type, path, options);
}

function validateObject(obj, type, path, options) {
  if (!type) {
    return [];
  }

  // Validate actual object itself
  let objChecks = [];
  if (type.validation) {
    objChecks = type.validation.map((() => {
      var _ref2 = _asyncToGenerator(function* (rule) {
        const ruleResults = yield rule.validate(obj, {
          parent: options.parent,
          document: options.document,
          path,
          type
        });

        return applyPath(ruleResults, path);
      });

      return function (_x3) {
        return _ref2.apply(this, arguments);
      };
    })());
  }

  // Validate fields within object
  const fields = type.fields || [];
  const fieldChecks = fields.map(field => {
    const validation = field.type.validation;
    if (!validation) {
      return [];
    }

    const fieldPath = appendPath(path, field.name);
    const fieldValue = obj[field.name];
    return validateItem(fieldValue, field.type, fieldPath, {
      parent: obj,
      document: options.document,
      path: fieldPath,
      type: field.type
    });
  });

  return Promise.all([...objChecks, ...fieldChecks]).then(flatten);
}

function validateArray(items, type, path, options) {
  // Validate actual array itself
  let arrayChecks = [];
  if (type.validation) {
    arrayChecks = type.validation.map((() => {
      var _ref3 = _asyncToGenerator(function* (rule) {
        const ruleResults = yield rule.validate(items, {
          parent: options.parent,
          document: options.document,
          path,
          type
        });

        return applyPath(ruleResults, path);
      });

      return function (_x4) {
        return _ref3.apply(this, arguments);
      };
    })());
  }

  // Validate items within array
  const itemChecks = items.map((item, i) => {
    const pathSegment = item._key ? { _key: item._key } : i;
    const itemType = resolveTypeForArrayItem(item, type.of);
    const itemPath = appendPath(path, [pathSegment]);
    return validateItem(item, itemType, itemPath, {
      parent: items,
      document: options.document,
      path: itemPath
    });
  });

  return Promise.all([...arrayChecks, ...itemChecks]).then(flatten);
}

function validatePrimitive(item, type, path, options) {
  if (!type.validation) {
    return [];
  }

  const results = type.validation.map(rule => rule.validate(item, { parent: options.parent, document: options.document, path }).then(currRuleResults => applyPath(currRuleResults, path)));

  return Promise.all(results).then(flatten);
}

function resolveTypeForArrayItem(item, candidates) {
  const primitive = !item._type && Type.string(item).toLowerCase();
  if (primitive) {
    return candidates.find(candidate => candidate.jsonType === primitive);
  }

  return candidates.find(candidate => candidate.type.name === item._type) || candidates.find(candidate => candidate.name === item._type);
}

function appendPath(base, next) {
  return base.concat(next);
}

function applyPath(results, pathPrefix) {
  return results.map(result => {
    const path = typeof result.path === 'undefined' ? pathPrefix : pathPrefix.concat(result.path);
    return _extends({ type: 'validation' }, result, { path });
  });
}