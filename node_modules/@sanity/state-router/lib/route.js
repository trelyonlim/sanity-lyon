'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = route;

var _parseRoute = require('./parseRoute');

var _parseRoute2 = _interopRequireDefault(_parseRoute);

var _resolveStateFromPath = require('./resolveStateFromPath');

var _resolveStateFromPath2 = _interopRequireDefault(_resolveStateFromPath);

var _resolvePathFromState = require('./resolvePathFromState');

var _resolvePathFromState2 = _interopRequireDefault(_resolvePathFromState);

var _paramsEncoding = require('./utils/paramsEncoding');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*:: import type {Transform, Router, RouteChildren} from './types'*/
/*:: type NodeOptions = {
  path?: string,
  children?: RouteChildren,
  transform?: {[key: string]: Transform<*>},
  scope?: string
}*/


function normalizeChildren(children /*: any*/) /*: RouteChildren*/ {
  if (Array.isArray(children) || typeof children === 'function') {
    return children;
  }
  return children ? [children] : [];
}

function isRoute(val /*: NodeOptions | Router | RouteChildren*/) {
  return val && '_isRoute' in val;
}

function normalizeArgs(path /*: string | NodeOptions*/, childrenOrOpts /*: NodeOptions | Router | RouteChildren*/, children /*: Router | RouteChildren*/) /*: NodeOptions*/ {
  if (typeof path === 'object') {
    return path;
  }
  if (Array.isArray(childrenOrOpts) || typeof childrenOrOpts === 'function' || isRoute(childrenOrOpts)) {
    return { path, children: normalizeChildren(childrenOrOpts) };
  }
  if (children) {
    return _extends({ path }, childrenOrOpts, { children: normalizeChildren(children) });
  }
  return _extends({ path }, childrenOrOpts);
}

function route(routeOrOpts /*: string | NodeOptions*/, childrenOrOpts /*: NodeOptions | RouteChildren*/, children /*: Router | RouteChildren*/) /*: Router*/ {
  return createNode(normalizeArgs(routeOrOpts, childrenOrOpts, children));
}

route.scope = function scope(scopeName /*: string*/, ...rest /*: any[]*/) /*: Router*/ {
  const options = normalizeArgs(...rest);

  return createNode(_extends({}, options, {
    scope: scopeName
  }));
};

function normalize(...paths) {
  return paths.reduce((acc, path) => acc.concat(path.split('/')), []).filter(Boolean);
}

route.intents = function intents(base) {
  const basePath = normalize(base).join('/');
  return route(`${basePath}/:intent`, [route(':params', {
    transform: {
      params: {
        toState: _paramsEncoding.decodeParams,
        toPath: _paramsEncoding.encodeParams
      }
    }
  })]);
};

const EMPTY_STATE = {};
function isRoot(pathname /*: string*/) /*: boolean*/ {
  const parts = pathname.split('/');
  for (let i = 0; i < parts.length; i++) {
    if (parts[i]) {
      return false;
    }
  }
  return true;
}

function createNode(options /*: NodeOptions*/) /*: Router*/ {
  const path = options.path,
        scope = options.scope,
        transform = options.transform,
        children = options.children;

  if (!path) {
    throw new TypeError('Missing path');
  }
  const parsedRoute = (0, _parseRoute2.default)(path);

  return {
    _isRoute: true, // todo: make a Router class instead
    scope,
    route: parsedRoute,
    children: children || [],
    transform,
    encode(state) {
      return (0, _resolvePathFromState2.default)(this, state);
    },
    decode(_path) {
      return (0, _resolveStateFromPath2.default)(this, _path);
    },
    isRoot: isRoot,
    isNotFound(pathname /*: string*/) /*: boolean*/ {
      return this.decode(pathname) === null;
    },
    getBasePath() /*: string*/ {
      return this.encode(EMPTY_STATE);
    },
    getRedirectBase(pathname /*: string*/) /*: ?string*/ {
      if (isRoot(pathname)) {
        const basePath = this.getBasePath();
        // Check if basepath is something different than given
        if (pathname !== basePath) {
          return basePath;
        }
      }
      return null;
    }
  };
}