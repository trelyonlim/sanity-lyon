'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _flatten2 = require('lodash/flatten');

var _flatten3 = _interopRequireDefault(_flatten2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = slateStateToBlocks;

var _randomKey = require('../util/randomKey');

var _randomKey2 = _interopRequireDefault(_randomKey);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toSanitySpan(node, sanityBlock, spanIndex) {
  if (node.kind === 'text') {
    return node.ranges.map(range => {
      return {
        _type: 'span',
        _key: `${sanityBlock._key}${spanIndex()}`,
        text: range.text,
        marks: range.marks.map(mark => mark.type)
      };
    });
  }
  if (node.kind === 'inline') {
    const nodes = node.nodes,
          data = node.data;

    return (0, _flatten3.default)(nodes.map(nodesNode => {
      if (nodesNode.kind !== 'text') {
        throw new Error(`Unexpected non-text child node for inline text: ${nodesNode.kind}`);
      }
      if (node.type !== 'span') {
        return node.data.value;
      }
      const annotations = data.annotations;
      const annotationKeys = [];
      if (annotations) {
        Object.keys(annotations).forEach(name => {
          const annotation = annotations[name];
          const annotationKey = annotation._key;
          if (annotation && annotationKey) {
            sanityBlock.markDefs.push(annotation);
            annotationKeys.push(annotationKey);
          }
        });
      }
      return nodesNode.ranges.map(range => ({
        _type: 'span',
        _key: `${sanityBlock._key}${spanIndex()}`,
        text: range.text,
        marks: range.marks.map(mark => mark.type).concat(annotationKeys)
      }));
    }));
  }
  throw new Error(`Unsupported kind ${node.kind}`);
}

function toSanityBlock(block) {
  if (block.type === 'contentBlock') {
    const sanityBlock = _extends({}, block.data, {
      _type: 'block',
      _key: block.key || block.data._key || (0, _randomKey2.default)(12),
      markDefs: []
    });
    let index = 0;
    const spanIndex = () => {
      return index++;
    };
    sanityBlock.children = (0, _flatten3.default)(block.nodes.map(node => {
      return toSanitySpan(node, sanityBlock, spanIndex);
    }));
    return sanityBlock;
  }
  return block.data.value;
}

function isEmpty(blocks) {
  if (blocks.length === 0) {
    return true;
  }
  if (blocks.length > 1) {
    return false;
  }
  const firstBlock = blocks[0];
  if (firstBlock._type !== 'block') {
    return false;
  }
  const children = firstBlock.children;
  if (children.length === 0) {
    return true;
  }
  if (children.length > 1) {
    return false;
  }
  const firstChild = children[0];
  if (firstChild._type !== 'span') {
    return false;
  }
  return firstChild.text.length === 0;
}

function slateStateToBlocks(json) {
  const nodes = (0, _get3.default)(json, 'document.nodes');
  if (!nodes || nodes.length === 0) {
    return undefined;
  }
  const blocks = nodes.map(toSanityBlock).filter(Boolean);
  return isEmpty(blocks) ? undefined : blocks;
}