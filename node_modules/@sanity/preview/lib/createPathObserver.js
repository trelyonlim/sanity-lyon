'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _uniq2 = require('lodash/uniq');

var _uniq3 = _interopRequireDefault(_uniq2);

var _isObject2 = require('lodash/isObject');

var _isObject3 = _interopRequireDefault(_isObject2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = createPathObserver;

var _observable = require('@sanity/observable');

var _observable2 = _interopRequireDefault(_observable);

var _observableProps = require('observable-props');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

/*:: import type {FieldName, Id, Path, Reference, Document, Value} from './types'*/


const props = (0, _observableProps.configure)({ Observable: _observable2.default });

function isReference(value /*: Reference | Document | Object*/) {
  return '_ref' in value;
}

function isDocument(value /*: Reference | Document | Object*/) {
  return '_id' in value;
}

function createEmpty(fields /*: FieldName[]*/) /*: Object*/ {
  return fields.reduce((result, field) => {
    result[field] = undefined;
    return result;
  }, {});
}

function resolveMissingHeads(value, paths) {
  return paths.filter(path => !(path[0] in value));
}

/*:: type ObserveFieldsFn = (id: string, fields: FieldName[]) => any*/


function observePaths(value /*: Value*/, paths /*: Path[]*/, observeFields /*: ObserveFieldsFn*/) {
  if (!(0, _isObject3.default)(value)) {
    // Reached a leaf. Return as is
    return _observable2.default.of(value);
  }
  const pathsWithMissingHeads = resolveMissingHeads(value, paths);
  if (pathsWithMissingHeads.length > 0) {
    // Reached a node that is either a document (with _id), or a reference (with _ref) that
    // needs to be "materialized"

    const nextHeads = (0, _uniq3.default)(pathsWithMissingHeads.map(path => path[0]));

    const isRef = isReference(value);
    if (isReference(value) || isDocument(value)) {
      const id = isRef ? value._ref : value._id;
      return observeFields(id, nextHeads).switchMap(snapshot => {
        if (snapshot === null) {
          return _observable2.default.of(null);
        }
        return observePaths(_extends({}, createEmpty(nextHeads), isRef ? {} : value, snapshot), paths, observeFields);
      });
    }
  }

  // We have all the fields needed already present on value
  const leads = {};
  paths.forEach(path => {
    var _path = _toArray(path);

    const head = _path[0],
          tail = _path.slice(1);

    if (!leads[head]) {
      leads[head] = [];
    }
    leads[head].push(tail);
  });

  const next = Object.keys(leads).reduce((res, head) => {
    const tails = leads[head];
    if (tails.every(tail => tail.length === 0)) {
      res[head] = value[head];
    } else {
      res[head] = observePaths(value[head], tails, observeFields);
    }
    return res;
  }, _extends({}, value));

  return props(_observable2.default.of(next), { wait: true });
}

// Normalizes path arguments so it supports both dot-paths and array paths, e.g.
// - ['propA.propB', 'propA.propC']
// - [['propA', 'propB'], ['propA', 'propC']]

function normalizePaths(path /*: FieldName[] | Path[]*/) /*: Path[]*/ {
  return path.map(segment => typeof segment === 'string' ? segment.split('.') : segment);
}

// Supports passing either an id or a value (document/reference/object)
function normalizeValue(value /*: Value | Id*/) /*: Value*/ {
  return typeof value === 'string' ? { _id: value } : value;
}

function createPathObserver(observeFields /*: ObserveFieldsFn*/) {
  return (value /*: Value*/, paths /*: Path[]*/) => observePaths(normalizeValue(value), normalizePaths(paths), observeFields);
}