'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.invokePrepare = undefined;

var _uniqBy2 = require('lodash/uniqBy');

var _uniqBy3 = _interopRequireDefault(_uniqBy2);

var _flatten2 = require('lodash/flatten');

var _flatten3 = _interopRequireDefault(_flatten2);

var _debounce2 = require('lodash/debounce');

var _debounce3 = _interopRequireDefault(_debounce2);

var _pick2 = require('lodash/pick');

var _pick3 = _interopRequireDefault(_pick2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

exports.default = prepareForPreview;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const pass = v => v;
const PRESERVE_KEYS = ['_id', '_type', '_upload'];

let COLLECTED_ERRORS = {};

const reportErrors = (0, _debounce3.default)(() => {
  /* eslint-disable no-console */
  const uniqueErrors = (0, _flatten3.default)(Object.keys(COLLECTED_ERRORS).map(typeName => {
    const entries = COLLECTED_ERRORS[typeName];
    return (0, _uniqBy3.default)(entries, entry => entry.error.message);
  }));
  const errorCount = uniqueErrors.length;
  console.groupCollapsed(`%cHeads up! Got ${errorCount === 1 ? 'error' : `${errorCount} errors`} while preparing data for preview. Click for details.` + ' This may be a hard failure in production and cause your application to crash.', 'color: #ff7e7c');

  Object.keys(COLLECTED_ERRORS).forEach(typeName => {
    const entries = COLLECTED_ERRORS[typeName];
    const first = entries[0];
    console.group(`%o for type "${typeName}" (x${entries.length})`, first.type.preview.prepare);
    (0, _uniqBy3.default)(entries, entry => entry.error.message).forEach(entry => {
      const value = entry.value,
            error = entry.error;

      console.log('The call to prepare(%o) failed with:', value);
      console.error(error);
    });
    console.groupEnd();
  });
  console.groupEnd();
  COLLECTED_ERRORS = {};
  /* eslint-enable no-console */
}, 1000);

function invokePrepareChecked(type, value, viewOptions) {
  const prepare = type.preview.prepare;
  if (!prepare) {
    return value;
  }
  try {
    return prepare(value, viewOptions);
  } catch (error) {
    if (!COLLECTED_ERRORS[type.name]) {
      COLLECTED_ERRORS[type.name] = [];
    }
    COLLECTED_ERRORS[type.name].push({ error: error, type, value });
    reportErrors();
  }
  return value;
}

function invokePrepareUnchecked(type, value, viewOptions) {
  return (type.preview.prepare || pass)(value, viewOptions);
}

const invokePrepare = exports.invokePrepare = __DEV__ ? invokePrepareChecked : invokePrepareUnchecked;

function prepareForPreview(rawValue, type, viewOptions) {
  const selection = type.preview.select;
  const targetKeys = Object.keys(selection);

  const remapped = targetKeys.reduce((acc, key) => {
    acc[key] = (0, _get3.default)(rawValue, selection[key]);
    return acc;
  }, (0, _pick3.default)(rawValue, PRESERVE_KEYS));

  return invokePrepare(type, remapped, viewOptions);
}