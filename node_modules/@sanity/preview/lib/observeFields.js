'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _difference2 = require('lodash/difference');

var _difference3 = _interopRequireDefault(_difference2);

var _flatten2 = require('lodash/flatten');

var _flatten3 = _interopRequireDefault(_flatten2);

exports.default = cachedObserveFields;

var _client = require('part:@sanity/base/client');

var _client2 = _interopRequireDefault(_client);

var _observable = require('@sanity/observable');

var _observable2 = _interopRequireDefault(_observable);

var _debounceCollect = require('./utils/debounceCollect');

var _debounceCollect2 = _interopRequireDefault(_debounceCollect);

var _optimizeQuery = require('./utils/optimizeQuery');

var _constants = require('./constants');

var _hasEqualFields = require('./utils/hasEqualFields');

var _hasEqualFields2 = _interopRequireDefault(_hasEqualFields);

var _isUniqueBy = require('./utils/isUniqueBy');

var _isUniqueBy2 = _interopRequireDefault(_isUniqueBy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*:: import type {FieldName, Id} from './types'*/


let _globalListener;
const getGlobalEvents = () => {
  if (!_globalListener) {
    const allEvents$ = _observable2.default.from(_client2.default.listen('*[!(_id in path("_.**"))]', {}, { events: ['welcome', 'mutation'], includeResult: false })).share();

    // This will keep the listener active forever and in turn reduce the number of initial fetches
    // as less 'welcome' events will be emitted.
    // @todo: see if we can delay unsubscribing or connect with some globally defined shared listener
    allEvents$.subscribe();

    _globalListener = {
      // This is a stream of welcome events from the server, each telling us that we have established listener connection
      // We map these to snapshot fetch/sync. It is good to wait for the first welcome event before fetching any snapshots as, we may miss
      // events that happens in the time period after initial fetch and before the listener is established.
      welcome$: allEvents$.filter(event => event.type === 'welcome').publishReplay(1).refCount(),
      mutations$: allEvents$.filter(event => event.type === 'mutation')
    };
  }
  return _globalListener;
};

function listen(id /*: Id*/) {
  const globalEvents = getGlobalEvents();
  return globalEvents.welcome$.merge(globalEvents.mutations$.filter(event => event.documentId === id));
}

function fetchAllDocumentPaths(selections /*: Selection[]*/) {
  const combinedSelections = (0, _optimizeQuery.combineSelections)(selections);
  return _client2.default.observable.fetch((0, _optimizeQuery.toGradientQuery)(combinedSelections)).map(result => (0, _optimizeQuery.reassemble)(result, combinedSelections));
}

const fetchDocumentPathsFast = (0, _debounceCollect2.default)(fetchAllDocumentPaths, 100);
const fetchDocumentPathsSlow = (0, _debounceCollect2.default)(fetchAllDocumentPaths, 1000);

function listenFields(id /*: Id*/, fields /*: FieldName[]*/) {
  return listen(id).switchMap(event => {
    if (event.type === 'welcome') {
      return fetchDocumentPathsFast(id, fields).mergeMap(result => {
        return result === undefined ? // hack: if we get undefined as result here it is most likely because the document has
        // just been created and is not yet indexed. We therefore need to wait a bit and then re-fetch.
        fetchDocumentPathsSlow(id, fields) : _observable2.default.of(result);
      });
    }
    return fetchDocumentPathsSlow(id, fields);
  });
}

// keep for debugging purposes for now
// function fetchDocumentPaths(id, selection) {
//   return client.observable.fetch(`*[_id==$id]{_id,_type,${selection.join(',')}}`, {id})
//     .map(result => result[0])
// }

/*:: type CachedFieldObserver = {
  id: Id,
  fields: FieldName[],
  changes$: Observable
}*/
/*:: type Cache = {[id: Id]: CachedFieldObserver[]}*/

const CACHE /*: Cache*/ = {}; // todo: use a LRU cache instead (e.g. hashlru or quick-lru)

function createCachedFieldObserver(id, fields) /*: CachedFieldObserver*/ {
  let latest = null;
  const changes$ = new _observable2.default(observer => {
    observer.next(latest);
    observer.complete();
  }).filter(Boolean).merge(listenFields(id, fields)).do(v => latest = v).publishReplay(1).refCount();

  return { id, fields, changes$ };
}

function cachedObserveFields(id /*: Id*/, fields /*: FieldName[]*/) {
  if (!(id in CACHE)) {
    CACHE[id] = [];
  }

  const existingObservers = CACHE[id];
  const missingFields = (0, _difference3.default)(fields, (0, _flatten3.default)(existingObservers.map(cachedFieldObserver => cachedFieldObserver.fields)));

  if (missingFields.length > 0) {
    existingObservers.push(createCachedFieldObserver(id, fields));
  }

  const cachedFieldObservers = existingObservers.filter(observer => observer.fields.some(fieldName => fields.includes(fieldName))).map(cached => cached.changes$);

  return _observable2.default.combineLatest(cachedFieldObservers)
  // in the event that a document gets deleted, the cached values will be updated to store `undefined`
  // if this happens, we should not pick any fields from it, but rather just return null
  .map(snapshots => snapshots.filter(Boolean))
  // make sure all snapshots agree on same revision
  .filter(snapshots => (0, _isUniqueBy2.default)(snapshots, snapshot => snapshot._rev))
  // pass on value with the requested fields (or null if value is deleted)
  .map(snapshots => snapshots.length === 0 ? null : pickFrom(snapshots, fields))
  // emit values only if changed
  .distinctUntilChanged((0, _hasEqualFields2.default)(fields));
}

function pickFrom(objects /*: Object[]*/, fields /*: string[]*/) {
  return [..._constants.INCLUDE_FIELDS, ...fields].reduce((result, fieldName) => {
    const value = getFirstFieldValue(objects, fieldName);
    if (value !== undefined) {
      result[fieldName] = value;
    }
    return result;
  }, {});
}

function getFirstFieldValue(objects /*: Object[]*/, fieldName /*: string*/) {
  let value;
  objects.some(object => {
    if (fieldName in object) {
      value = object[fieldName];
      return true;
    }
    return false;
  });
  return value;
}