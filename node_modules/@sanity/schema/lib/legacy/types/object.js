'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectType = undefined;

var _startCase2 = require('lodash/startCase');

var _startCase3 = _interopRequireDefault(_startCase2);

var _keyBy2 = require('lodash/keyBy');

var _keyBy3 = _interopRequireDefault(_keyBy2);

var _pick2 = require('lodash/pick');

var _pick3 = _interopRequireDefault(_pick2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _utils = require('./utils');

var _createPreviewGetter = require('../preview/createPreviewGetter');

var _createPreviewGetter2 = _interopRequireDefault(_createPreviewGetter);

var _guessOrderingConfig = require('../ordering/guessOrderingConfig');

var _guessOrderingConfig2 = _interopRequireDefault(_guessOrderingConfig);

var _resolveSearchFields = require('../resolveSearchFields');

var _resolveSearchFields2 = _interopRequireDefault(_resolveSearchFields);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

const OVERRIDABLE_FIELDS = ['jsonType', 'orderings', 'type', 'name', 'title', 'readOnly', 'hidden', 'description', '__unstable_searchFields', 'options', 'inputComponent'];

const ObjectType = {
  get() {
    return {
      name: 'object',
      type: null,
      jsonType: 'object'
    };
  },
  extend(rawSubTypeDef, createMemberType) {
    const subTypeDef = _extends({ fields: [] }, rawSubTypeDef);

    const options = _extends({}, subTypeDef.options || {});
    const parsed = Object.assign((0, _pick3.default)(this.get(), OVERRIDABLE_FIELDS), subTypeDef, {
      type: this.get(),
      title: subTypeDef.title || (subTypeDef.name ? (0, _startCase3.default)(subTypeDef.name) : ''),
      options: options,
      orderings: subTypeDef.orderings || (0, _guessOrderingConfig2.default)(subTypeDef),
      fields: subTypeDef.fields.map(fieldDef => {
        const name = fieldDef.name,
              fieldset = fieldDef.fieldset,
              rest = _objectWithoutProperties(fieldDef, ['name', 'fieldset']);

        const compiledField = {
          name,
          fieldset
        };

        return (0, _utils.lazyGetter)(compiledField, 'type', () => {
          return createMemberType(_extends({}, rest, {
            title: fieldDef.title || (0, _startCase3.default)(name)
          }));
        });
      })
    });

    (0, _utils.lazyGetter)(parsed, 'fieldsets', () => {
      return createFieldsets(subTypeDef, parsed.fields);
    });

    (0, _utils.lazyGetter)(parsed, 'preview', (0, _createPreviewGetter2.default)(subTypeDef));

    (0, _utils.lazyGetter)(parsed, '__unstable_searchFields', () => (0, _resolveSearchFields2.default)(parsed), {
      enumerable: false
    });

    return subtype(parsed);

    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          if (extensionDef.fields) {
            throw new Error('Cannot override `fields` of subtypes of "object"');
          }
          const current = Object.assign({}, parent, (0, _pick3.default)(extensionDef, OVERRIDABLE_FIELDS), {
            title: extensionDef.title || subTypeDef.title,
            type: parent
          });
          (0, _utils.lazyGetter)(current, '__unstable_searchFields', () => parent.__unstable_searchFields);
          return subtype(current);
        }
      };
    }
  }
};

exports.ObjectType = ObjectType;
function createFieldsets(typeDef, fields) {
  const fieldsetsDef = typeDef.fieldsets || [];
  const fieldsets = fieldsetsDef.map(fieldset => {
    const name = fieldset.name,
          title = fieldset.title,
          description = fieldset.description,
          options = fieldset.options;

    return {
      name,
      title,
      description,
      options,
      fields: []
    };
  });

  const fieldsetsByName = (0, _keyBy3.default)(fieldsets, 'name');

  return fields.map(field => {
    if (field.fieldset) {
      const fieldset = fieldsetsByName[field.fieldset];
      if (!fieldset) {
        throw new Error(`Group '${field.fieldset}' is not defined in schema for type '${typeDef.name}'`);
      }
      fieldset.fields.push(field);
      // Return the fieldset if its the first time we encounter a field in this fieldset
      return fieldset.fields.length === 1 ? fieldset : null;
    }
    return { single: true, field };
  }).filter(Boolean);
}