'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = urlForImage;
exports.parseSource = parseSource;
var SPEC_NAME_TO_URL_NAME_MAPPINGS = [['width', 'w'], ['height', 'h'], ['format', 'fm'], ['download', 'dl'], ['blur', 'blur'], ['sharpen', 'sharp'], ['invert', 'invert'], ['orientation', 'or'], ['minHeight', 'min-h'], ['maxHeight', 'max-h'], ['minWidth', 'min-w'], ['maxWidth', 'max-w'], ['quality', 'q'], ['fit', 'fit'], ['crop', 'crop']];

function urlForImage(options) {
  var spec = Object.assign({}, options || {});
  var source = spec.source;
  delete spec.source;

  var image = parseSource(source);
  if (!image) {
    return null;
  }

  var asset = parseAssetId(image.asset._ref);

  // Compute crop rect in terms of pixel coordinates in the raw source image
  var crop = {
    left: Math.round(image.crop.left * asset.width),
    top: Math.round(image.crop.top * asset.height)
  };

  crop.width = Math.round(asset.width - image.crop.right * asset.width - crop.left);
  crop.height = Math.round(asset.height - image.crop.bottom * asset.height - crop.top);

  // Compute hot spot rect in terms of pixel coordinates
  var hotSpotVerticalRadius = image.hotspot.height * asset.height / 2;
  var hotSpotHorizontalRadius = image.hotspot.width * asset.width / 2;
  var hotSpotCenterX = image.hotspot.x * asset.width;
  var hotSpotCenterY = image.hotspot.y * asset.height;
  var hotspot = {
    left: hotSpotCenterX - hotSpotHorizontalRadius,
    top: hotSpotCenterY - hotSpotVerticalRadius,
    right: hotSpotCenterX + hotSpotHorizontalRadius,
    bottom: hotSpotCenterY + hotSpotHorizontalRadius
  };

  spec.asset = asset;

  // If irrelevant, or if we are requested to: don't perform crop/fit based on
  // the crop/hotspot.
  if (!(spec.rect || spec.focalPoint || spec.ignoreImageParams || spec.crop)) {
    spec = Object.assign(spec, fit({ crop: crop, hotspot: hotspot }, spec));
  }

  return specToImageUrl(spec);
}

// Convert an asset-id, asset or image to an image record suitable for processing
function parseSource(source) {
  var image = void 0;

  // Did we just get an asset id?
  if (typeof source === 'string') {
    image = {
      asset: { _ref: source }
    };
  } else if (source._type === 'sanity.imageAsset' || (typeof source === 'undefined' ? 'undefined' : _typeof(source)) === 'object' && typeof source._ref === 'string') {
    // We just got passed an asset directly
    image = {
      asset: source
    };
  } else if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) === 'object' && _typeof(source.asset) === 'object') {
    image = source;
  } else {
    // We got something that does not look like an image, or it is an image
    // that currently isn't sporting an asset.
    return null;
  }

  if (!image.crop || !image.hotspot) {
    // Mock crop and hotspot if image lacks it
    image = Object.assign({
      crop: {
        left: 0,
        top: 0,
        bottom: 0,
        right: 0
      },
      hotspot: {
        x: 0.5,
        y: 0.5,
        height: 1.0,
        width: 1.0
      }
    }, image);
  }

  return image;
}

function parseAssetId(ref) {
  var _ref$split = ref.split('-'),
      _ref$split2 = _slicedToArray(_ref$split, 4),
      id = _ref$split2[1],
      dimensionString = _ref$split2[2],
      format = _ref$split2[3];

  if (!(typeof dimensionString === 'string')) {
    throw new Error('Malformed asset _ref \'' + ref + '\'. Expected an id on the form "image-Tb9Ew8CXIwaY6R1kjMvI0uRR-2000x3000-jpg.');
  }

  var _dimensionString$spli = dimensionString.split('x'),
      _dimensionString$spli2 = _slicedToArray(_dimensionString$spli, 2),
      imgWidthStr = _dimensionString$spli2[0],
      imgHeightStr = _dimensionString$spli2[1];

  var width = +imgWidthStr;
  var height = +imgHeightStr;

  if (!(typeof id === 'string' && typeof format === 'string' && Number.isFinite(width) && Number.isFinite(height))) {
    throw new Error('Malformed asset _ref \'' + ref + '\'. Expected an id on the form "image-Tb9Ew8CXIwaY6R1kjMvI0uRR-2000x3000-jpg.');
  }

  return { id: id, width: width, height: height, format: format };
}

// eslint-disable-next-line complexity
function specToImageUrl(spec) {
  var cdnUrl = spec.baseUrl || 'https://cdn.sanity.io';
  var filename = spec.asset.id + '-' + spec.asset.width + 'x' + spec.asset.height + '.' + spec.asset.format;
  var baseUrl = cdnUrl + '/images/' + spec.projectId + '/' + spec.dataset + '/' + filename;

  var params = [];

  if (spec.rect) {
    // Only bother url with a crop if it actually crops anything
    var isEffectiveCrop = spec.rect.left != 0 || spec.rect.top != 0 || spec.rect.height != spec.asset.height || spec.rect.width != spec.asset.width;
    if (isEffectiveCrop) {
      params.push('rect=' + spec.rect.left + ',' + spec.rect.top + ',' + spec.rect.width + ',' + spec.rect.height);
    }
  }

  if (spec.focalPoint) {
    params.push('fp-x=' + spec.focalPoint.x);
    params.push('fp-x=' + spec.focalPoint.y);
  }

  if (spec.flipHorizontal || spec.flipVertical) {
    params.push('flip=' + (spec.flipHorizontal ? 'h' : '') + (spec.flipVertical ? 'v' : ''));
  }

  // Map from spec name to url param name
  SPEC_NAME_TO_URL_NAME_MAPPINGS.forEach(function (mapping) {
    var _mapping = _slicedToArray(mapping, 2),
        specName = _mapping[0],
        param = _mapping[1];

    if (typeof spec[specName] != 'undefined') {
      params.push(param + '=' + encodeURIComponent(spec[specName]));
    }
  });

  if (params.length === 0) {
    return baseUrl;
  }

  return baseUrl + '?' + params.join('&');
}
/* eslint-enable complexity */

function fit(source, spec) {
  var result = {
    width: spec.width,
    height: spec.height

    // If we are not constraining the aspect ratio, we'll just use the whole crop
  };if (!(spec.width && spec.height)) {
    result.rect = source.crop;
    return result;
  }

  var crop = source.crop;
  var hotspot = source.hotspot;

  // If we are here, that means aspect ratio is locked and fitting will be a bit harder
  var desiredAspectRatio = spec.width / spec.height;
  var cropAspectRatio = crop.width / crop.height;

  if (cropAspectRatio > desiredAspectRatio) {
    // The crop is wider than the desired aspect ratio. That means we are cutting from the sides
    var _height = crop.height;
    var _width = _height * desiredAspectRatio;
    var _top = crop.top;
    // Center output horizontally over hotspot
    var hotspotXCenter = (hotspot.right - hotspot.left) / 2 + hotspot.left;
    var _left = hotspotXCenter - _width / 2;
    // Keep output within crop
    if (_left < crop.left) {
      _left = crop.left;
    } else if (_left + _width > crop.left + crop.width) {
      _left = crop.left + crop.width - _width;
    }
    result.rect = {
      left: Math.round(_left),
      top: Math.round(_top),
      width: Math.round(_width),
      height: Math.round(_height)
    };
    return result;
  }
  // The crop is taller than the desired ratio, we are cutting from top and bottom
  var width = crop.width;
  var height = width / desiredAspectRatio;
  var left = crop.left;
  // Center output vertically over hotspot
  var hotspotYCenter = (hotspot.bottom - hotspot.top) / 2 + hotspot.top;
  var top = hotspotYCenter - height / 2;
  // Keep output rect within crop
  if (top < crop.top) {
    top = crop.top;
  } else if (top + height > crop.top + crop.height) {
    top = crop.top + crop.height - height;
  }
  result.rect = {
    left: Math.floor(left),
    top: Math.floor(top),
    width: Math.round(width),
    height: Math.round(height)
  };
  return result;
}